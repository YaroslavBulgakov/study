'''
Итак вспомним что в пайтоне  у нас имеются изменяемые и не изменяемые типы данных
Это целый тип, вещественный тип, строки, множества, кортежи, байтс
Изменяемые - словари, списки, байтаррау
Кстати множества могут включать только неизменяемы пермееные а ключами словапей только неизменяемые объекты
Также в пайтон переменные это ссылки на объекты
Пример ниже
То есть сначал создается объект с именме blue затем ссылка на него
потом еще один а вто треться создает ееще одну ссылку на объект уже ранее созданный поэтому если изменим х то z также измениться
'''
import copy
x="blue"
y="green"
z=x
print(x,y,z)
#А вот тут нет z так и останенться blue
x='black'
print(x,y,z)
print('------------------Перепревязки переменных------------')
x="blue"
y="green"
z=x
print(x,y,z)
z=y
print('Print must be blue green green |',x,y,z)
x=z
print('Print must be green green green |',x,y,z)

#Когда мы создаем список то создаются в списки не объекты а ссылки на сами объекты это важно при копировании двумерных списков
#то есть для двумерных важно делать полнуюю копю так как если присвоим один другому то как бы будет ссылкться на один и тот же обхект
ls=[[1,2],[3,4]]
print('ID of ls[1]:',id(ls[1]))
ls2=ls
print('ID of ls2[1]:',id(ls2[1]))
print('LS is ',ls)
print('LS2 is ',ls2)
ls[1][0]=10
print('After change first ls ',ls2)
ls=[[1,2],[3,4]]
#И то только функцией дипкопи можно делать
ls2=copy.deepcopy(ls)
ls[1][0]=10
print('This after copy change first ls ',ls2)

print('--------------------Кортежи и списки------------------')
#Если мы создаем кортеж с 1 элементом
#А если просто пустой
tp=()
print('Empty tuple only ()',type(tp))
tp=(1)
print('Tuple with 1 element without , ',type(tp))
tp=(1,)
print('Tuple with 1 element with , ',type(tp))
#А вот при созданнии списка запятая не нужна
ls=[1]
print('List with 1 element without ,',type(ls))
ls=[1,]
print('List with 1 element with ,',type(ls))
#---------------------Методы списков----------------
'''
insert[i,value] - вставляет в позициую знаечние
remove(x) - удаляет с который первым попадется с таким значением
pop[i] - удаляет и возвращает элемент по индексу
count(x) - количество элементов со значением х
sort.(key=функция) - сортировка на основе функции
append
extend- и так понятно
copy - поверхностная не глубокая копия списка
clear  - очистит
'''
ls=[]
ls.insert(0,'value1')
ls.insert(0,'value2')
#Тут у нас получиться что value2 бдут первым т.к вставилиего в нулевую позицию последним
print(ls)

ls2=['wild','wild','duck','bery']
ls.extend(ls2)
print(ls)
print('Count of wild :',ls.count('wild'))
ls.remove('wild')
print('After remove wild',ls)

#Оператор идентичности is - вернет ТРУ если ссылка обе переменные ссылаются на 1 и тот же объект  а также лля прверки типов
a=10
if type(a) is int:
    print('Yes type is int')
ls1=['Ret',3,None]
ls2=['Ret',3,None]
print(ls1 is ls2)
ls1=ls2
print(ls1 is ls2)
#А вот если == использовать то оно не проверяет ссылаются ли на одну и ту же память просто сравнивает обхеты
print('-------Is or == ----------')
a='to long'
b='to long'
print(a is b)
print(a==b)

a=10
#Цепочка например что а между 0 и 20
print(0<=a<=20)

#Оператор членства проверяет входит ли что-то в список иле же другой набюор
print('----------in-------------')
st='adaddsasx'
print('a' in st)
print('z' in st)

#and ели одно ложь то вернет ложь типа второе а если правда то также второе
five=5
two=2
zero=0

print(five and two)
print(two and five)
print(five and zero)

#Ор аернте тру если хотя бы один типа тру или больше 0 ну типа если тру то вернеться первый
print('---------or-----------')
nought=0
print(five or two)
print(two or five)
print(zero or five)
print(zero or nought)

#Еще вот пишут что 4 пробельных отсутпа типа стандарт но интерпретаор справляется с любым да хер там на линкусе выдает ошибку
#Также помним что списки можно складывать типа вставляет элемент в конец и наервно еможно и перемножать
seeds=['seasame','glower']
seeds+=['pumpkin']
print(seeds)
#Можно самого себя перемножить как и строку
print(seeds*2)
tp=tuple(seeds)
print(tp*2)

